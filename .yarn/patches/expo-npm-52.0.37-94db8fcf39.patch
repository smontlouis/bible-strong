diff --git a/src/dom/dom-entry.tsx b/src/dom/dom-entry.tsx
index 43a920aa9d1ec3457b070aeaa9adcfbca844614d..592bb21236e501adab94f2ba5420f06a2efd11aa 100644
--- a/src/dom/dom-entry.tsx
+++ b/src/dom/dom-entry.tsx
@@ -1,25 +1,25 @@
 // Entry file for a DOM Component.
-import '@expo/metro-runtime';
+import '@expo/metro-runtime'
 
-import { withErrorOverlay } from '@expo/metro-runtime/error-overlay';
-import React from 'react';
+import { withErrorOverlay } from '@expo/metro-runtime/error-overlay'
+import React from 'react'
 
-import { addEventListener, getActionsObject } from './marshal';
-import registerRootComponent from '../launch/registerRootComponent';
+import { addEventListener, getActionsObject } from './marshal'
+import registerRootComponent from '../launch/registerRootComponent'
 
-declare let window: any;
+declare let window: any
 
-const ACTIONS = getActionsObject!();
+const ACTIONS = getActionsObject!()
 
 function isBaseObject(obj: any) {
   if (Object.prototype.toString.call(obj) !== '[object Object]') {
-    return false;
+    return false
   }
-  const proto = Object.getPrototypeOf(obj);
+  const proto = Object.getPrototypeOf(obj)
   if (proto === null) {
-    return true;
+    return true
   }
-  return proto === Object.prototype;
+  return proto === Object.prototype
 }
 
 function isErrorShaped(error: any): error is Error {
@@ -28,7 +28,7 @@ function isErrorShaped(error: any): error is Error {
     typeof error === 'object' &&
     typeof error.name === 'string' &&
     typeof error.message === 'string'
-  );
+  )
 }
 
 /**
@@ -37,80 +37,84 @@ function isErrorShaped(error: any): error is Error {
  */
 function convertError(error: any) {
   if (isErrorShaped(error)) {
-    return error;
+    return error
   }
 
   if (process.env.NODE_ENV === 'development') {
     if (error == null) {
-      return new Error('A null/undefined error was thrown.');
+      return new Error('A null/undefined error was thrown.')
     }
   }
 
   if (isBaseObject(error)) {
-    return new Error(JSON.stringify(error));
+    return new Error(JSON.stringify(error))
   }
 
-  return new Error(String(error));
+  return new Error(String(error))
 }
 
 export function registerDOMComponent(AppModule: any) {
   function DOMComponentRoot(props) {
     // Props listeners
-    const [marshalledProps, setProps] = React.useState(() => {
-      if (typeof window.$$EXPO_INITIAL_PROPS === 'undefined') {
-        throw new Error(
-          'Initial props are not defined. This is a bug in the DOM Component runtime.'
-        );
-      }
-      return window.$$EXPO_INITIAL_PROPS;
-    });
+    const [marshalledProps, setProps] = React.useState(undefined)
 
     React.useEffect(() => {
       const remove = addEventListener!((msg) => {
         if (msg.type === '$$props') {
-          setProps(msg.data);
+          setProps(msg.data)
         }
-      });
+      })
       return () => {
-        remove();
-      };
-    }, [setProps]);
+        remove()
+      }
+    }, [setProps])
 
     const proxyActions = React.useMemo(() => {
-      if (!marshalledProps.names) return {};
+      if (!marshalledProps?.names) return {}
       // Create a named map { [name: string]: ProxyFunction }
-      return Object.fromEntries(
-        marshalledProps.names.map((key) => {
-          return [key, ACTIONS[key]];
-        })
-      );
-    }, [marshalledProps.names]);
-
-    return <AppModule {...props} {...(marshalledProps.props || {})} {...proxyActions} />;
+      return marshalledProps.names.reduce((acc, key) => {
+        acc[key] = ACTIONS[key]
+        return acc
+      }, {})
+    }, [marshalledProps?.names])
+
+    if (!marshalledProps) {
+      return null
+    }
+
+    return (
+      <AppModule
+        {...props}
+        {...(marshalledProps.props || {})}
+        {...proxyActions}
+      />
+    )
   }
 
   try {
     React.startTransition(() => {
       if (process.env.NODE_ENV !== 'production') {
-        registerRootComponent(withErrorOverlay(DOMComponentRoot));
+        registerRootComponent(withErrorOverlay(DOMComponentRoot))
       } else {
-        registerRootComponent(DOMComponentRoot);
+        registerRootComponent(DOMComponentRoot)
       }
-    });
+    })
   } catch (e) {
-    const error = convertError(e);
+    const error = convertError(e)
     // Prevent the app from throwing confusing:
     //  ERROR  Invariant Violation: "main" has not been registered. This can happen if:
     // * Metro (the local dev server) is run from the wrong folder. Check if Metro is running, stop it and restart it in the current project.
     // * A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.
-    registerRootComponent(() => React.createElement('div'));
+    registerRootComponent(() => React.createElement('div'))
 
-    console.error(error);
-    console.error(`A runtime error has occurred while rendering the root component.`);
+    console.error(error)
+    console.error(
+      `A runtime error has occurred while rendering the root component.`
+    )
 
     // Give React a tick to render before throwing.
     setTimeout(() => {
-      throw error;
-    });
+      throw error
+    })
   }
 }
diff --git a/src/dom/webview-wrapper.tsx b/src/dom/webview-wrapper.tsx
index 3ee2761fd9070c770ecb53ef4ade67ba7dac524d..84dd8899c1a01d1950c7e8c1e2676d3a6804d9ad 100644
--- a/src/dom/webview-wrapper.tsx
+++ b/src/dom/webview-wrapper.tsx
@@ -1,10 +1,15 @@
 // A webview without babel to test faster.
-import React from 'react';
-import { AppState } from 'react-native';
-
-import { getBaseURL } from './base';
-import type { BridgeMessage, DOMProps, WebViewProps, WebViewRef } from './dom.types';
-import { _emitGlobalEvent } from './global-events';
+import React from 'react'
+import { AppState } from 'react-native'
+
+import { getBaseURL } from './base'
+import type {
+  BridgeMessage,
+  DOMProps,
+  WebViewProps,
+  WebViewRef,
+} from './dom.types'
+import { _emitGlobalEvent } from './global-events'
 import {
   getInjectBodySizeObserverScript,
   getInjectEventScript,
@@ -12,198 +17,213 @@ import {
   NATIVE_ACTION,
   NATIVE_ACTION_RESULT,
   REGISTER_DOM_IMPERATIVE_HANDLE_PROPS,
-} from './injection';
-import ExpoDomWebView from './webview/ExpoDOMWebView';
-import RNWebView from './webview/RNWebView';
-import { useDebugZeroHeight } from './webview/useDebugZeroHeight';
+} from './injection'
+import ExpoDomWebView from './webview/ExpoDOMWebView'
+import RNWebView from './webview/RNWebView'
+import { useDebugZeroHeight } from './webview/useDebugZeroHeight'
 
 interface Props {
-  dom?: DOMProps;
-  filePath: string;
+  dom?: DOMProps
+  filePath: string
 }
 
-const RawWebView = React.forwardRef<object, Props>(({ dom, filePath, ...marshalProps }, ref) => {
-  if (ref != null && typeof ref === 'object' && ref.current == null) {
-    ref.current = new Proxy(
-      {},
-      {
-        get(_, prop) {
-          const propName = String(prop);
-          if (domImperativeHandlePropsRef.current?.includes(propName)) {
-            return function (...args) {
-              const serializedArgs = args.map((arg) => JSON.stringify(arg)).join(',');
-              webviewRef.current?.injectJavaScript(
-                `window._domRefProxy.${propName}(${serializedArgs})`
-              );
-            };
-          }
-          if (typeof webviewRef.current?.[propName] === 'function') {
-            return function (...args) {
-              return webviewRef.current?.[propName](...args);
-            };
-          }
-          return undefined;
-        },
-      }
-    );
-  }
-
-  const webView = resolveWebView(dom?.useExpoDOMWebView ?? false);
-  const webviewRef = React.useRef<WebViewRef>(null);
-  const domImperativeHandlePropsRef = React.useRef<string[]>([]);
-  const source = { uri: `${getBaseURL()}/${filePath}` };
-  const [containerStyle, setContainerStyle] = React.useState<WebViewProps['containerStyle']>(null);
-
-  const { debugZeroHeightStyle, debugOnLayout } = useDebugZeroHeight(dom);
-
-  const emit = React.useCallback(
-    (detail: BridgeMessage<any>) => {
-      webviewRef.current?.injectJavaScript(getInjectEventScript(detail));
-    },
-    [webviewRef]
-  );
-
-  // serializable props, action names.
-
-  const smartActions = Object.entries(marshalProps).reduce<{
-    props: Record<string, any>;
-    names: string[];
-  }>(
-    (acc, [key, value]) => {
-      if (value instanceof Function) {
-        acc.names.push(key);
-      } else {
-        // TODO: Recurse and assert that nested functions cannot be used.
-        acc.props[key] = value;
-      }
-      return acc;
-    },
-    { names: [], props: {} }
-  );
-
-  // When the `marshalProps` change, emit them to the webview.
-  React.useEffect(() => {
-    emit({ type: '$$props', data: smartActions });
-  }, [emit, smartActions]);
-
-  return React.createElement(webView, {
-    webviewDebuggingEnabled: __DEV__,
-    // Make iOS scrolling feel native.
-    decelerationRate: process.env.EXPO_OS === 'ios' ? 'normal' : undefined,
-    // This is a better default for integrating with native navigation.
-    contentInsetAdjustmentBehavior: 'automatic',
-    // This is the default in ScrollView and upstream native.
-    automaticallyAdjustsScrollIndicatorInsets: true,
-    originWhitelist: ['*'],
-    allowFileAccess: true,
-    allowFileAccessFromFileURLs: true,
-    allowingReadAccessToURL: 'file://',
-    allowsAirPlayForMediaPlayback: true,
-    allowsFullscreenVideo: true,
-    onContentProcessDidTerminate: () => {
-      webviewRef.current?.reload();
-    },
-    onRenderProcessGone: () => {
-      // Simulate iOS `onContentProcessDidTerminate` behavior to reload when the app is in foreground or back to foreground.
-      if (AppState.currentState === 'active') {
-        webviewRef.current?.reload();
-        return;
-      }
-      const subscription = AppState.addEventListener('focus', () => {
-        webviewRef.current?.reload();
-        subscription.remove();
-      });
-    },
-    ...dom,
-    containerStyle: [containerStyle, debugZeroHeightStyle, dom?.containerStyle],
-    onLayout: __DEV__ ? debugOnLayout : dom?.onLayout,
-    injectedJavaScriptBeforeContentLoaded: [
-      // On first mount, inject `$$EXPO_INITIAL_PROPS` with the initial props.
-      `window.$$EXPO_INITIAL_PROPS = ${JSON.stringify(smartActions)};true;`,
-      dom?.matchContents ? getInjectBodySizeObserverScript() : null,
-      dom?.injectedJavaScriptBeforeContentLoaded,
-      'true;',
-    ]
-      .filter(Boolean)
-      .join('\n'),
-    ref: webviewRef,
-    source,
-    style: [
-      dom?.style ? { flex: 1, backgroundColor: 'transparent' } : { backgroundColor: 'transparent' },
-      dom?.style,
-    ],
-    onMessage: (event) => {
-      const { type, data } = JSON.parse(event.nativeEvent.data);
-
-      if (type === MATCH_CONTENTS_EVENT) {
-        if (dom?.matchContents) {
-          setContainerStyle({
-            width: data.width,
-            height: data.height,
-          });
+const RawWebView = React.forwardRef<object, Props>(
+  ({ dom, filePath, ...marshalProps }, ref) => {
+    if (ref != null && typeof ref === 'object' && ref.current == null) {
+      ref.current = new Proxy(
+        {},
+        {
+          get(_, prop) {
+            const propName = String(prop)
+            if (domImperativeHandlePropsRef.current?.includes(propName)) {
+              return function (...args) {
+                const serializedArgs = args
+                  .map((arg) => JSON.stringify(arg))
+                  .join(',')
+                webviewRef.current?.injectJavaScript(
+                  `window._domRefProxy.${propName}(${serializedArgs})`
+                )
+              }
+            }
+            if (typeof webviewRef.current?.[propName] === 'function') {
+              return function (...args) {
+                return webviewRef.current?.[propName](...args)
+              }
+            }
+            return undefined
+          },
+        }
+      )
+    }
+
+    const webView = resolveWebView(dom?.useExpoDOMWebView ?? false)
+    const webviewRef = React.useRef<WebViewRef>(null)
+    const domImperativeHandlePropsRef = React.useRef<string[]>([])
+    const source = { uri: `${getBaseURL()}/${filePath}` }
+    const [containerStyle, setContainerStyle] =
+      React.useState<WebViewProps['containerStyle']>(null)
+
+    const { debugZeroHeightStyle, debugOnLayout } = useDebugZeroHeight(dom)
+
+    const emit = React.useCallback(
+      (detail: BridgeMessage<any>) => {
+        webviewRef.current?.injectJavaScript(getInjectEventScript(detail))
+      },
+      [webviewRef]
+    )
+
+    // serializable props, action names.
+
+    const smartActions = Object.entries(marshalProps).reduce<{
+      props: Record<string, any>
+      names: string[]
+    }>(
+      (acc, [key, value]) => {
+        if (value instanceof Function) {
+          acc.names.push(key)
+        } else {
+          // TODO: Recurse and assert that nested functions cannot be used.
+          acc.props[key] = value
         }
-        return;
-      }
-
-      if (type === REGISTER_DOM_IMPERATIVE_HANDLE_PROPS) {
-        domImperativeHandlePropsRef.current = data;
-        return;
-      }
-
-      if (type === NATIVE_ACTION) {
-        const action = marshalProps[data.actionId];
-        if (action == null) {
-          throw new Error(`Native action "${data.actionId}" is not defined.`);
+        return acc
+      },
+      { names: [], props: {} }
+    )
+
+    // When the `marshalProps` change, emit them to the webview.
+    React.useEffect(() => {
+      emit({ type: '$$props', data: smartActions })
+    }, [emit, smartActions])
+
+    return React.createElement(webView, {
+      webviewDebuggingEnabled: __DEV__,
+      // Make iOS scrolling feel native.
+      decelerationRate: process.env.EXPO_OS === 'ios' ? 'normal' : undefined,
+      // This is a better default for integrating with native navigation.
+      contentInsetAdjustmentBehavior: 'automatic',
+      // This is the default in ScrollView and upstream native.
+      automaticallyAdjustsScrollIndicatorInsets: true,
+      originWhitelist: ['*'],
+      allowFileAccess: true,
+      allowFileAccessFromFileURLs: true,
+      allowingReadAccessToURL: 'file://',
+      allowsAirPlayForMediaPlayback: true,
+      allowsFullscreenVideo: true,
+      onContentProcessDidTerminate: () => {
+        webviewRef.current?.reload()
+      },
+      onRenderProcessGone: () => {
+        // Simulate iOS `onContentProcessDidTerminate` behavior to reload when the app is in foreground or back to foreground.
+        if (AppState.currentState === 'active') {
+          webviewRef.current?.reload()
+          return
         }
-        if (typeof action !== 'function' || !(action instanceof Function)) {
-          throw new Error(`Native action "${data.actionId}" is not a function.`);
+        const subscription = AppState.addEventListener('focus', () => {
+          webviewRef.current?.reload()
+          subscription.remove()
+        })
+      },
+      ...dom,
+      containerStyle: [
+        containerStyle,
+        debugZeroHeightStyle,
+        dom?.containerStyle,
+      ],
+      onLayout: __DEV__ ? debugOnLayout : dom?.onLayout,
+      onLoad: () => {
+        emit({ type: '$$props', data: smartActions })
+      },
+      injectedJavaScriptForMainFrameOnly: true,
+      injectedJavaScript: [
+        dom?.matchContents ? getInjectBodySizeObserverScript() : null,
+        dom?.injectedJavaScript,
+        'true;',
+      ]
+        .filter(Boolean)
+        .join('\n'),
+      ref: webviewRef,
+      source,
+      style: [
+        dom?.style
+          ? { flex: 1, backgroundColor: 'transparent' }
+          : { backgroundColor: 'transparent' },
+        dom?.style,
+      ],
+      onMessage: (event) => {
+        const { type, data } = JSON.parse(event.nativeEvent.data)
+
+        if (type === MATCH_CONTENTS_EVENT) {
+          if (dom?.matchContents) {
+            setContainerStyle({
+              width: data.width,
+              height: data.height,
+            })
+          }
+          return
         }
 
-        const emitError = (error) => {
-          emit({
-            type: NATIVE_ACTION_RESULT,
-            data: {
-              uid: data.uid,
-              actionId: data.actionId,
-              error: serializeError(error),
-            },
-          });
-        };
-        const emitResolve = (result?: any) => {
-          // Send async results back to the DOM proxy for return values.
-          emit({
-            type: NATIVE_ACTION_RESULT,
-            data: {
-              uid: data.uid,
-              actionId: data.actionId,
-              result,
-            },
-          });
-        };
-        try {
-          const value = action(...data.args);
-          if (value instanceof Promise) {
-            return value
-              .then((result) => {
-                emitResolve(result);
-              })
-              .catch((error) => {
-                emitError(error);
-              });
-          } else {
-            // Send async results back to the webview proxy for return values.
-            return emitResolve(value);
+        if (type === REGISTER_DOM_IMPERATIVE_HANDLE_PROPS) {
+          domImperativeHandlePropsRef.current = data
+          return
+        }
+
+        if (type === NATIVE_ACTION) {
+          const action = marshalProps[data.actionId]
+          if (action == null) {
+            throw new Error(`Native action "${data.actionId}" is not defined.`)
+          }
+          if (typeof action !== 'function' || !(action instanceof Function)) {
+            throw new Error(
+              `Native action "${data.actionId}" is not a function.`
+            )
+          }
+
+          const emitError = (error) => {
+            emit({
+              type: NATIVE_ACTION_RESULT,
+              data: {
+                uid: data.uid,
+                actionId: data.actionId,
+                error: serializeError(error),
+              },
+            })
           }
-        } catch (error) {
-          return emitError(error);
+          const emitResolve = (result?: any) => {
+            // Send async results back to the DOM proxy for return values.
+            emit({
+              type: NATIVE_ACTION_RESULT,
+              data: {
+                uid: data.uid,
+                actionId: data.actionId,
+                result,
+              },
+            })
+          }
+          try {
+            const value = action(...data.args)
+            if (value instanceof Promise) {
+              return value
+                .then((result) => {
+                  emitResolve(result)
+                })
+                .catch((error) => {
+                  emitError(error)
+                })
+            } else {
+              // Send async results back to the webview proxy for return values.
+              return emitResolve(value)
+            }
+          } catch (error) {
+            return emitError(error)
+          }
+        } else {
+          dom?.onMessage?.(event)
         }
-      } else {
-        dom?.onMessage?.(event);
-      }
-      _emitGlobalEvent({ type, data });
-    },
-  });
-});
+        _emitGlobalEvent({ type, data })
+      },
+    })
+  }
+)
 
 function serializeError(error: any) {
   if (error instanceof Error) {
@@ -211,20 +231,22 @@ function serializeError(error: any) {
       message: error.message,
       stack: error.stack,
       // TODO: Other props...
-    };
+    }
   }
-  return error;
+  return error
 }
 
 export function resolveWebView(useExpoDOMWebView: boolean) {
-  const webView = useExpoDOMWebView ? ExpoDomWebView : RNWebView;
+  const webView = useExpoDOMWebView ? ExpoDomWebView : RNWebView
   if (webView == null) {
-    const moduleName = useExpoDOMWebView ? '@expo/dom-webview' : 'react-native-webview';
+    const moduleName = useExpoDOMWebView
+      ? '@expo/dom-webview'
+      : 'react-native-webview'
     throw new Error(
       `Unable to resolve the '${moduleName}' module. Make sure to install it with 'npx expo install ${moduleName}'.`
-    );
+    )
   }
-  return webView;
+  return webView
 }
 
-export default RawWebView;
+export default RawWebView
